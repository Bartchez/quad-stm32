/*******************************************************************************
* File Name      : S65DISP.c
* Description    : C Code for S65 Display
*******************************************************************************/

#include "lcd_ls020.h"
#include "utils.h"

/*
Pining Siemens S65 Display on H103

RS     ...  PC7
RESET  ...  PC8
CS     ...  PC9
CLK    ...  PB13 - SPI2.SCK
DAT    ...  PB15 - SP2I.MOSI
 */


const uint16_t S65_CMD_INIT1[2]  = { 0xFDFD, 0xFDFD };
const uint16_t S65_CMD_INIT2[10] = { 0xEF00, 0xEE04, 0x1B04, 0xFEFE, 0xFEFE, 0xEF90, 0x4A04, 0x7F3F, 0xEE04, 0x4306};
const uint16_t S65_CMD_INIT3[20] = { 0xEF90, 0x0983, 0x0800, 0x0BAF, 0x0A00, 0x0500, 0x0600, 0x0700, 0xEF00, 0xEE0C,
                                     0xEF90, 0x0080, 0xEFB0, 0x4902, 0xEF00, 0x7F01, 0xE181, 0xE202, 0xE276, 0xE183};
const uint16_t S65_CMD_INIT4[3]  = { 0x8001, 0xEF90, 0x0000 }; 

// ascii table, starting with character blank (32)
// size is 8x14
const char ascii_tab[]  ={
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // space (32)
 0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0x3c, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, //!
 0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //"
 0x00, 0x00, 0x00, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x00, 0x00, //#
 0x00, 0x18, 0x18, 0x7c, 0xc6, 0xc2, 0xc0, 0x7c, 0x06, 0x86, 0xc6, 0x7c, 0x18, 0x18, //$
 0x00, 0x00, 0x00, 0x00, 0x00, 0xc2, 0xc6, 0x0c, 0x18, 0x30, 0x66, 0xc6, 0x00, 0x00, // %
 0x00, 0x00, 0x00, 0x38, 0x6c, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0xcc, 0x76, 0x00, 0x00, // &
 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // '
 0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00, 0x00, // (
 0x00, 0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00, 0x00, // )
 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, // *
 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, // +
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, // ´
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // -
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, // .
 0x00, 0x00, 0x00, 0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00, 0x00, 0x00, // /
 0x00, 0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xd6, 0xc6, 0xc6, 0x6c, 0x38, 0x00, 0x00, // 0 (48-32)
 0x00, 0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x06, 0x06, 0x3c, 0x06, 0x06, 0xc6, 0x7c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x0c, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x0c, 0x1e, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0, 0xfc, 0x06, 0x06, 0xc6, 0x7c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x38, 0x60, 0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xfe, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x06, 0x0c, 0x78, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x0c, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xde, 0xde, 0xde, 0xdc, 0xc0, 0x7c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x66, 0xfc, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xc0, 0xc2, 0x66, 0x3c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xf8, 0x6c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x62, 0x66, 0xfe, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0xf0, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xde, 0xc6, 0x66, 0x3a, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xe6, 0x66, 0x6c, 0x6c, 0x78, 0x6c, 0x6c, 0x66, 0xe6, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xf0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xc6, 0xee, 0xfe, 0xd6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xc6, 0xe6, 0xf6, 0xfe, 0xde, 0xce, 0xc6, 0xc6, 0xc6, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0xf0, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xde, 0x7c, 0x0e, 0x00,
 0x00, 0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x66, 0xe6, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x60, 0x38, 0x0c, 0xc6, 0xc6, 0x7c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x5a, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xd6, 0xfe, 0x6c, 0x6c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0x7c, 0x38, 0x7c, 0xc6, 0xc6, 0xc6, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xfe, 0xc6, 0x8c, 0x18, 0x30, 0x60, 0xc2, 0xc6, 0xfe, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0x70, 0x38, 0x1c, 0x0e, 0x06, 0x02, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00, 0x00,
 0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
 0x00, 0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00, 0x00,
 0x00, 0x00, 0x00, 0xe0, 0x60, 0x60, 0x78, 0x6c, 0x66, 0x66, 0x66, 0x7c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x1c, 0x0c, 0x0c, 0x3c, 0x6c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc6, 0x7c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x1c, 0x36, 0x32, 0x30, 0x7c, 0x30, 0x30, 0x30, 0x78, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xcc, 0x78,
 0x00, 0x00, 0x00, 0xe0, 0x60, 0x60, 0x6c, 0x76, 0x66, 0x66, 0x66, 0xe6, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x06, 0x06, 0x00, 0x0e, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3c,
 0x00, 0x00, 0x00, 0xe0, 0x60, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xec, 0xfe, 0xd6, 0xd6, 0xd6, 0xd6, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0x0c, 0x1e,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0x60, 0xf0, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x70, 0x1c, 0xc6, 0x7c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x10, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x36, 0x1c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xd6, 0xd6, 0xfe, 0x6c, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c, 0x78,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xcc, 0x18, 0x30, 0x66, 0xfe, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x0e, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x0e, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0e, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00,
 0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00, 0x00, 0x00,
};       

void LS020_DrawPixelXY(uint8_t x, uint8_t y, uint16_t color)
{
 LS020_wrcmd(0xEF90);
 LS020_wrcmd(0x0504);
 LS020_wrcmd(0x0800+x);
 LS020_wrcmd(0x0A00+y);
 LS020_wrcmd(0x0900+x);
 LS020_wrcmd(0x0B00+y);
 LS020_wrdat(color);
}

//******************************************************************************
//  Name: 			ls020_DrawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint8_t color)
// 	Copyright:		Free to use at will & at own risk.
// 	Author: 		JCP
// 	Date: 			03.30.06 17:10
//  Description:    To draw a line from the LCD
// 	Useage:			n6100DrawLine(param 1,param 2,param 3,param 4,param 5)
//					param 1: x start direction: 0-131
//					param 2: y start direction: 0-131
//					param 3: x end direction: 0-131
//					param 4: y end direction: 0-131
//					param 5: Color of Pixel, RRRGGGBB format
//	Example:		ls020_DrawLine(20,100,70,100,MAGENTA);	
//					
//  Notes:			No bounds checking	
//*******************************************************************************
void LS020_DrawLine(uint8_t x1, uint8_t y1, uint8_t x2, uint8_t y2, uint16_t color) 
{
 int x,y,count,xs,ys,xm,ym;

 x=(int)x1; y=(int)y1;
 xs=(int)x2-(int)x1; ys=(int)y2-(int)y1;
 if(xs<0) xm=-1; else if(xs>0) xm=1; else xm=0;
 if(ys<0) ym=-1; else if(ys>0) ym=1; else ym=0;
// xs=abs(xs);  ys=abs(ys);
 if(xs<0) xs=-xs;
 if(ys<0) ys=-ys;

 LS020_DrawPixelXY((unsigned char)x,(unsigned char)y, color);

 if(xs>ys) // Flache Linie <45 Grad
  {
   count=-(xs/2);
   while(x!=x2 )
    {
     count=count+ys;
     x=x+xm;
     if(count>0)
      {
       y=y+ym;
       count=count-xs;
      }

     LS020_DrawPixelXY((unsigned char)x,(unsigned char)y, color);
    }
   }
  else // Steile Linie >=45 Grad
   {
    count=-(ys/2);
    while(y!=y2)
    {
     count=count+xs;
     y=y+ym;
     if(count>0)
      {
       x=x+xm;
       count=count-ys;
      }
     LS020_DrawPixelXY((unsigned char)x,(unsigned char)y, color);
    }
   }
}

//*****************************************************************************
//	Name: 			LS020_DrawRect(uint8_t sr1,uint8_t sr2,uint8_t szer,uint8_t wys, uint8_t color)
// 	Copyright:		Free to use at will & at own risk.
// 	Author: 		JCP
// 	Date: 			03.30.06 17:10
// 	Description:    To draw a BOX on the LCD  
// 	Useage:			LS020_DrawRect(param 1,param 2,param 3,param 4,param 5)
//					param 1: x start direction: 0-131
//					param 2: y start direction: 0-131
//					param 3: width: 0-131
//					param 4: heighth: 0-131
//					param 5: Color of Pixel, RRRGGGBB format
//
//	Example:	    LS020_DrawRect(0,0,132,132,Black);  // fill entire screen with black color
//					
//  Notes:			No bounds checking	
//*******************************************************************************
void LS020_DrawRect(uint8_t sr1,uint8_t sr2,uint8_t szer,uint8_t wys, uint8_t color) 
{

 LS020_DrawLine(sr1,sr2,szer,sr2, color);
 LS020_DrawLine(szer,sr2,szer,wys, color);
 LS020_DrawLine(szer,wys,sr1,wys, color);
 LS020_DrawLine(sr1,wys,sr1,sr2, color); 

}

//******************************************************************************
// 	Name:      		ls020_DrawCircle(uint8_t xCenter, uint8_t yCenter, uint8_t radius, uint8_t color)
// 	Copyright: 		Free to use at will & at own risk.
// 	Date: 			03.30.06 17:10
// 	Description:    To Draw a Circle on LCD
// 	Useage:			n6100DrawCircle(param 1,param 2,param 3,param 4)
//
//					param 1: x location on screen, 0 - 127
//					param 2: y location on screen, 0 - 63
//					param 3: diameter of circle
//                  param 4: Color of Pixel, RRRGGGBB format
//
//	Example:        ls020_DrawCircle(40,30,30,LightGreen);
//  Notes:			No bounds checking	
//*******************************************************************************
void LS020_DrawCircle(uint8_t xCenter, uint8_t yCenter, uint8_t radius, uint16_t color) 
{
 int16_t tSwitch, y, x = 0;
 uint8_t d;

 d = yCenter - xCenter;
 y = radius;
 tSwitch = 3 - 2 * radius;
  	
 while (x <= y) {
   	LS020_DrawPixelXY(xCenter + x, yCenter + y, color);
   	LS020_DrawPixelXY(xCenter + x, yCenter - y, color);
   	
   	LS020_DrawPixelXY(xCenter - x, yCenter + y, color);
   	LS020_DrawPixelXY(xCenter - x, yCenter - y, color);
   	
   	LS020_DrawPixelXY(yCenter + y - d, yCenter + x, color);
   	LS020_DrawPixelXY(yCenter + y - d, yCenter - x, color);
    	
   	LS020_DrawPixelXY(yCenter - y - d, yCenter + x, color);
   	LS020_DrawPixelXY(yCenter - y - d, yCenter - x, color);

   	if (tSwitch < 0) 
  	 tSwitch += (4 * x + 6);
	else 
	 {
      tSwitch += (4 * (x - y) + 10);
      y--;
     }
    x++;
  	}
}
/*******************************************************************************
* Function Name  : ls020_clrscr
* Description    : CClear screen
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void LS020_clrscr(void)
{
 uint16_t i;

 LS020_wrcmd(0xEF90);
 LS020_wrcmd(0x0504);
 LS020_wrcmd(0x0800);
 LS020_wrcmd(0x0A00);
 LS020_wrcmd(0x0900+131);
 LS020_wrcmd(0x0B00+175);

 for (i=0; i<DISP_W*DISP_H; i++)
  LS020_wrdat(0x0000);
}

/*******************************************************************************
* Function Name  : fill_screen
* Description    : fill color
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void LS020_fill_screen(uint16_t color)
{
 uint16_t i;

 LS020_wrcmd(0xEF90);
 LS020_wrcmd(0x0504);
 LS020_wrcmd(0x0800);
 LS020_wrcmd(0x0A00);
 LS020_wrcmd(0x0900+131);
 LS020_wrcmd(0x0B00+175);

 for (i=0; i<DISP_W*DISP_H; i++)
  LS020_wrdat(color);

}

// wrights a character in the default 5x7 font
void LS020_put_char(uint8_t x, uint8_t y, uint16_t textcolor, uint16_t backcolor, char c)
{
 uint8_t h,ch,p,mask ;

 LS020_wrcmd(0xEF90);
 LS020_wrcmd(0x0504);
 LS020_wrcmd(0x0800+y);
 LS020_wrcmd(0x0A00+x);
 LS020_wrcmd(0x0900+y+CHAR_H-1);
 LS020_wrcmd(0x0B00+x+CHAR_W-1);
 for (h=0; h<CHAR_H; h++) // every column of the character
  {
   ch = ascii_tab[(CHAR_H +(c-32)* CHAR_H)-h];
   mask=0x80;
   for (p=0; p<CHAR_W; p++)  // write the pixels
    {
	 if (ch&mask)
	  {
	   LS020_wrdat(textcolor);                
	  }
	 else
	  {
	   LS020_wrdat(backcolor);
	  }
	 mask>>=1;
	 }
  }
}

// wrights a character; the size is a multiple of the 5x7 font
void LS020_put_char_maxXY(uint8_t x, uint8_t y, uint16_t textcolor, uint16_t backcolor, uint8_t size, const char* c)
{
 
 uint8_t h,ch,p,mask,j,k;

 LS020_wrcmd(0xEF90);
 LS020_wrcmd(0x0504);
 LS020_wrcmd(0x0800+y);
 LS020_wrcmd(0x0A00+x);
 LS020_wrcmd(0x0900+y+(CHAR_H * size)-1);
 LS020_wrcmd(0x0B00+x+(CHAR_W * size)-1);
 for (h=0; h<CHAR_H; h++) // every column of the character
  {
   ch = ascii_tab[(CHAR_H +(*c-32)* CHAR_H)-h];
   for (j=0; j<size; j++)  
    {
	 mask=0x80;
	 for (p=0; p<CHAR_W; p++)  // write the pixels
	  {
	   if (ch&mask)
	    {
		 for (k=0; k<size; k++)	LS020_wrdat(textcolor);                
		}
	   	else
	     {
		  for (k=0; k<size; k++) LS020_wrdat(backcolor);
		 }
		mask>>=1;
	  }
	}
  }
}

// Shows a message-string in the RAM hor-centered
void LS020_message_centerXY(uint8_t x,uint8_t y, uint16_t textcolor, uint16_t backcolor, const char* string)
{
 uint8_t l;

 l = strLen((uint8_t *)string);
 if(l > (176/CHAR_W))	
 l = 176/CHAR_W;
	//xx = x - ((l/2)*CHAR_W);
 while(*string)
  {
   LS020_put_char(x, y, backcolor, textcolor, *string++);
   x += CHAR_W;
  }
}

/*******************************************************************************
* Function Name  : S65_init_GPIO
* Description    : Configures all the necessary GPIOs for the Display
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/

void S65_init_GPIO(void)
{
  GPIO_InitTypeDef GPIOS65Init;
  
  GPIOS65Init.GPIO_Pin   = LCD_PIN_RESET | LCD_PIN_RS | LCD_PIN_CS;
  GPIOS65Init.GPIO_Speed = GPIO_Speed_50MHz;
  GPIOS65Init.GPIO_Mode  = GPIO_Mode_Out_PP;
  GPIO_Init(LCD_PORT_LS020, &GPIOS65Init);

}

/*******************************************************************************
* Function Name  : S65_init_SPI
* Description    : Configures the SPI for the S65 Display 
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/

void S65_init_SPI(void)
{
SPI_InitTypeDef SPI_InitStructure;
GPIO_InitTypeDef GPIO_InitStructure;

  /* SPI2 Periph clock enable */
  RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);

//SCK, MISO and MOSI
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_Init(GPIOB, &GPIO_InitStructure);

  SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
  SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
  SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;
  SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
  SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
  SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
  SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
  SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
  SPI_InitStructure.SPI_CRCPolynomial= 7;
  SPI_Init(SPI2, &SPI_InitStructure);

  // Wlacz SPI2
  SPI_Cmd(SPI2, ENABLE);

/* Now you can send Data using SPI_I2S_SendData(SPI2, uint16_t Data)*/
}


/*******************************************************************************
* Function Name  : S65_send_CMD
* Description    : sends a 16Bit command through SPI2
* Input          : uint16_t CMD
* Output         : None
* Return         : None
*******************************************************************************/
void LS020_wrcmd(uint16_t cmd)
{
  CS_CLR; 								// select Display
  RS_SET; 								// set RS line = Command
  while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);
  SPI_I2S_SendData(SPI2, cmd);						//wyslij dane po SPI do LCD
  CS_SET;								// deselect Display
 // Delay_ms(10);
}


/*******************************************************************************
* Function Name  : S65_send_DATA
* Description    : sends  16Bit Data through SPI2
* Input          : uint16_t data
* Output         : None
* Return         : None
*******************************************************************************/
void LS020_wrdat(uint16_t data)
{
  CS_CLR; 								// select Display
  RS_CLR; 								// clear RS line = data
  while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_TXE) == RESET);       
  SPI_I2S_SendData(SPI2, data);						//wyslij dane po SPI do LCD
  CS_SET;								// deselect Display

}


/*******************************************************************************
* Function Name  : S65_init
* Description    : Initialize the Display based on the register values from superkranz.de
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
void S65_init(void)
{
  int i;

  RESET_CLR;
  Delay_ms(150);
  RESET_SET; /* Reset LINE = High */

  for (i = 0; i<2; i++)  LS020_wrcmd(S65_CMD_INIT1[i]);  /* 1. Init Sequence */
  Delay_ms(50);
  for (i = 0; i<10; i++) LS020_wrcmd(S65_CMD_INIT2[i]);  /* 2. Init Sequence */
  Delay_ms(7);  
  for (i = 0; i<20; i++) LS020_wrcmd(S65_CMD_INIT3[i]);  /* 3. Init Sequence */
  Delay_ms(50); 
  for (i = 0; i<3; i++)  LS020_wrcmd(S65_CMD_INIT4[i]);  /* 4. Init Sequence */
  Delay_ms(10); 
  /* Display is ready to use */
}


/*******************************************************************************
* Function Name  : S65_FillScreen
* Description    : Fills the Screen of the Display
* Input          : uint16_t color
* Output         : None
* Return         : None
*******************************************************************************/

void S65_FillScreen(uint16_t color)
{
  int i;
  LS020_wrcmd(0xEF90);
  LS020_wrcmd(0x0500);
  LS020_wrcmd(0x0600);
  LS020_wrcmd(0x0700);
  for (i=0; i<46464; i++) LS020_wrdat(color);  
}


/*******************************************************************************
* Function Name  : S65_DrawBitmap
* Description    : Draws a Bitmap
* Input          : u8 *bitmap...Pointer to the bitmap array 
                  (created by S65-Bitmap Converter from http://www.mikrocontroller.net/topic/59263#new (hagen))
* Output         : None
* Return         : None
*******************************************************************************/
void S65_DrawBitmap(u8 *bitmap)
{
  int i;
  uint16_t buffer;
  LS020_wrcmd(0xEF90);
  LS020_wrcmd(0x0500);
  LS020_wrcmd(0x0600);
  LS020_wrcmd(0x0700);
  for (i=0; i<19932; i++) /* Pixels to draw */
  {
    buffer = *bitmap << 8;
    bitmap++;
    buffer |= *bitmap;
    LS020_wrdat(buffer);  
    bitmap++;
  }
}

